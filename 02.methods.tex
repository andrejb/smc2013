%-----------------------------------------------------------------------------
% __  __      _   _               _     
%|  \/  | ___| |_| |__   ___   __| |___ 
%| |\/| |/ _ \ __| '_ \ / _ \ / _` / __|
%| |  | |  __/ |_| | | | (_) | (_| \__ \
%|_|  |_|\___|\__|_| |_|\___/ \__,_|___/
%-----------------------------------------------------------------------------

\section{Methods}
\label{sec:methods}

In order to meet the needs for real time audio processing, the microcontroller
has to be tweaked so we can capture, process and output analog audio. Each of
these tasks can be performed in a variety of ways, and for this examination we
chose to go with the basic functionalities of the platform.

In this investigation, we used an Arduino Duemilanove with an ATmega328P
microcontroller, a very modest version of the platform. It has an 8-bit RISC
central processor, operates with a base frequency of 16~MHz, and has memory
capacity of 32~KB for program storage and 2~KB for random access.

\subsection{Microcontroller's elements}

\setlength{\itemsep}{0em}

To be able to know how to configure the platform to suit our needs, a general
understanding of the inner workings of a microcontroller is needed. The Atmel
Atmel megaAVR series microcontroller is comprised of several components, some
of which are fundamental for our investigation and so will be briefly covered
in this section.

\subsubsection{Clocks}

Clocks provide the frequencies in which the different parts of the
microcontroller work. They are basically either emitters or dividers of square
wave signals that provide the frequency of operation of the CPU, the ADC,
the memory access, etc. Possible sources of clock frequencies are crystal
and RC oscillators.

A useful concept associated with clocks is the one of a \emph{prescaler}.
Prescalers are dividers for clock frequencies that either actually lower the
frequency of a clock or at least trigger specific interrupts on a power of two
fraction of a clock's frequency.

The \emph{system clock} provides the system's base frequency of operation. In
our study, we make use of the system clock prescaler to control the PWM
frequency that drives our DSP mechanism, as we will see in the section
\ref{sec:pwm}. Another important clock is the \emph{I/O clock} used for
feeding a frequency to most of the input/output mechanisms.

\subsubsection{Registers and interrupts}

The microcontroller's CPU is comprised of an arithmetic logic unit that works
with 32 \emph{registers} -- portions of memory that provide data for
computation as well as determine the execution flow of the program. An
\emph{interrupt} is a deviation from the execution flow that can be triggered
by a variety of events in the system, usually by setting values on specific
registers.

In our case, interrupts are of extreme value as they are the low level
structures that allow us to execute code with a somewhat fixed frequency (at
least if we assume that the clock frequency is fixed in relation with real
time).

\subsubsection{Timers/counters}

A \emph{timer}, or \emph{counter}, is a register whose value is automatically
incremented according to a specific clock. A certain timer has a fixed length
in bits and may have lots of interrupts associated with its behaviour. When a
counter hits its maximum value, for example, it is reset to zero and signals
an overflow interrupt, which may cause a function to be called.

Timers are important in the context of DSP because they provide the way to
perform many of the DSP chain tasks, as for example to periodically launch the
sampling function (that fills the input buffer) and to emmit a PWM square wave
which after (analog) filtering causes the digital signal to be converted back
to analog. The ATmega328P has two bit counters and one 16 bit counter, each
having different sets of features but all being capable of doing PWM.

\subsubsection{Input and output pins}

Microcontrollers can receive and emit digital signal through \emph{I/O pins},
which in the case of the the Arduino board are conveniently mounted in a way
it is easy to plug other components and boards. These pins are read from and
written to according to frequencies governed by different clocks (I/O, ADC and
others).

In principle, the microcontroller pins are designed to work with binary
signals represented by two different voltages, in general 0~V and 5~V, having
a threshold value to account for small deviations from these reference
voltages. Despite that, I/O pins come equipped with handy mechanisms for
sampling input signals with voltage varying between the reference extremes,
and also to generate waveforms that can be filtered to approximate varying
output signals of the same nature. These mechanisms are, respectively, the
analog-to-digital converter (ADC) and the pulse-width modulation (PWM), which
will be seen in the next couple of sessions.


\subsubsection{Memory}

The microcontroler has 3 different memory spaces: 32~KB of persistent flash memory for
program storage, 2~KB of non-persistent SRAM memory for data storage and 1~KB
of persistent EEPROM memory for data storage. The following table summarizes
some differences between each type of memory:

\begin{center}
\begin{tabular}{crrr}
\toprule
\toprule
\multicolumn{1}{c}{\footnotesize{type}} &
\multicolumn{1}{c}{\footnotesize{size (KB)}} &
\footnotesize{\parbox{5em}{write time (clock ticks)}} &
\footnotesize{\parbox{5em}{endurance (write/erase cycles)}} \\
\midrule
Flash  & 32 & 1 & 10,000 \\
SRAM   & 2  & 2 & 10,000 \\
EEPROM & 1  & 30 & 100,000 \\ 
\bottomrule
\end{tabular}
\end{center}



\subsection{Audio in: ADC}

Data can flow into the microcontroller in a variety of ways, the most basic
being an embedded serial communication mechanism and the input pins. The
former mechanism can feed digital data directly to memory, while the latter
can either read 1 bit (as explained in the last section) or sample an
intermediate value between the reference voltages using 8 or 10 bits for
representing that value.

Rather than providing the microcontroller with digital data, our setup uses
the analog-to-digital conversion to sample an audio signal using the
microcontroller pins' ADC mechanism. This choice was made so the signal can be
directly connected to the microcontroller (i.e. no external device has to be
used for sampling) and we can study the device's performance taking into
account this crucial step in the digital audio processing chain.

The ADC uses a \emph{Sample and Hold} circuit that holds the input voltage
at a constant level until the end of the conversion. This fixed voltage is
then successively compared with reference voltages to obtain a 10 bit
approximation. If a faster conversion is desired, precision can be sacrificed
and the first 8 bits can be read before the last 2 are computed. Conversion
time takes between 13 and 250~$\mu$s, depending on several configuration
parameters given to the ADC mechanism.

As noted before, the ADC mechanism has a dedicated clock to ensure conversion
can occur independently of other microcontroller parts. Also, the mechanism
can be triggered manually (on demand) or automatically (a new conversion
starts as soon as the last one finishes).

\subsection{Audio out: PWM}
\label{sec:pwm}

Once the input signal has been sampled and processed, one way to convert
it back to analog is to use the embedded PWM mechanism that is available in
some of the output pins of the microcontroller. PWM is a technique for
representing an intermediate value from two reference values that can have its
output filtered to reconstruct a bandwidth limited signal. In our case, this
filtering is made from a simple RC circuit that stands between the output pin
and a normal speaker.

For outputting the result, PWM conversion is used, followed by a simple
low pass filter.

PWM characteristics:

\begin{itemize}
    \item 6 output channels.
    \item Different modes of operation (fast PWM and phase correct PWM).
    \item prescaler.
    \item Two 8-bit counters and one 16-bit counter.
    \item Overflow interrupt.
\end{itemize}

\figura{pwmmeu}{0.40}{TODO: change captions.}
%\figura{pwm2}{0.35}{TODO: change captions.}
\figura{Pwm}{0.45}{TODO: change captions.}

Explain how we use PWM interrupts to determine the frequency of operation of
our DSP system (and other possibilities of how this could be done).


\subsection{Processing}

The main constraint in real time DSP is, of course, the amount of time
available for the computation of output samples: they must be ready to be
consumed by the playback hardware or else glitches and other unwanted
artifacts will possibly be introduced in the signal. One round of sample
analysis, processing and calculation of a new sample is called a \emph{DSP
cycle}. Many algorithms, though, operate in blocks of samples, consuming and
producing a whole block of samples in each round. Naturally, in these cases
the period of the DSP cycle is the period of one sample times the size of the
DSP block. If the DSP block period is of $N$ samples and the sample rate is
$R$~Hz, then the DSP cycle period is given by $T_{DSP}=\frac{N}{R}$ seconds.

In order to implement this behaviour in the microcontroller, we have to find a
way to (1) accumulate input samples in a buffer, (2) schedule a periodic call
to a function that will process the samples in this buffer, and (3) output
modified samples in a timely fashion. One possible solution is to use a
timer's overflow interrupt.

\subsubsection{DSP cycles}

\begin{itemize}
    \item We need a mechanism to periodically call a function that will work
    on a block of samples.
\end{itemize}

\subsubsection{ADC conversion}

The table below shows a measurement of conversion time using different
prescaler values for the ADC clock:

\begin{center}
\begin{tabular}{crrrr}
\toprule
\toprule
\footnotesize{prescaler} & \footnotesize{$f_\text{ADC}$ (KHz)} &
\footnotesize{$T_\text{ADC}$ ($\mu$s)} & \footnotesize{$\tilde{T}_\text{conv}$ ($\mu$s)} & \footnotesize{$\tilde{f}_\text{conv}$ ($\approx$Hz)} \\
\midrule
2 & 8.000 & 0,125 & 12,61 & 79.302\\
4 & 4.000 & 0,25 & 16,06  & 62.266 \\
%\rowcolor{grey}
8 & 2.000 & 0,50 & 19,76  & 50.607 \\
16& 1.000 & 1 & 20,52  & 48.732 \\
32& 500 & 2 & 34,80  & 28.735 \\
64& 250 & 3 & 67,89  & 14.729 \\
128& 125 & 8 & 114,85 & 8.707  \\
\bottomrule
\end{tabular}
\end{center}

These measurements were made using the \texttt{micros()} function of the
Arduino library API, which has a resolution of about 4~$\mu$s.

Obs:
\begin{itemize}
  \item The resolution of the \texttt{micros()} function is of 4~$\mu$s.
  \item Conversion period $\approx$ $14.5 \times T_\text{ADC}$. 
  \item $R=44100$~Hz $\Rightarrow$ $T_\text{amostra} \approx 22.67~\mu$s.
  \item $R=31250$~Hz $\Rightarrow$ $T_\text{amostra} = 32.00~\mu$s.
\end{itemize}

ADC parameter choice:

\begin{itemize}
    \item Left-aligned conversion (8 bits).
    \item Prescaler equals to 8.
\end{itemize}

\subsubsection{PWM}

Frequency of operation given an 8-bit counter and different values for
prescaler:

\begin{center}
\begin{tabular}{crrrr}
\toprule
\toprule
\footnotesize{prescaler} &
\footnotesize{$f_\text{incr}$ (KHz)} &
\footnotesize{$f_\text{overflow}$ (Hz)}  \\
\midrule
1 & 16.000 & 62.500 \\
8 & 2.000 & 7.812 \\
32 & 500 & 1.953 \\
64 & 250 & 976 \\
128 & 125 & 488 \\
256 & 62,5 & 244 \\
1024 & 15,625 & 61 \\
\bottomrule
\end{tabular}
\end{center}

Chose parameters:

\begin{itemize}
  \item \emph{Fast PWM}.
  \item 8-bit counter.
  \item Prescaler value of 1.
  \item Overflow frequency: 16~MHz / 1 / $2^8$ = 62500~Hz.
  \item Sample generation frequency: 31250~Hz.
\end{itemize}

\subsubsection{Putting it all together}

\begin{lstlisting}
/* 1. read from ADC input */
x[ind] = ADCH;

/* 2. write to PWM output */
OCR2A = y[(ind-MIN_DELAY)&(BUFFER_SIZE-1)];

// 3. signal availability of new sample block
if ((ind & (BLOCK_SIZE - 1)) == 0) {
  rind = (ind-BLOCK_SIZE) & (BUFFER_SIZE-1);
  dsp_block = true;
}

/* 4. increment read/write buffer index */
ind++;
ind &= BUFFER_SIZE - 1;

/* 5. start new ADC conversion */
sbi(ADCSRA,ADSC); 
\end{lstlisting}



\subsection{Benchmarking}

Once we have a way to input and output analog audio signals to and from the
Arduino board, then we can start to experiment and measure the time it takes
to perform common DSP routines in this environment.

Some questions arise immediately from such a constraint:

\begin{itemize}
    \item What is the maximum amount of operations that can be carried in real
    time?
    \item Which implementation details make a difference?
    \item What is the quality of the resulting audio signal?
\end{itemize}

\subsubsection{Additive synthesis}

An additive synthesis is the process of constructing a more complex waveform
by adding together several more basic waveforms (see Figure \ref{fig:add}).
This technique has been widely used for synthesizing new sounds as well as
resynthesizing signals after they went through some computational procedure.

\figura{add}{0.20}{Additive synthesis.}


The high level code for a simple additive synthesis can be seen below:

\begin{lstlisting}[caption=Additive synthesis algorithm.]
for (n = 0; n < N; n++)
{
  angle = 2.0 * M_PI * t;
  y[n] = 0.0;
  for (k = 0; k < numFreqs; k++)
    y[n] += r[k]*sin(f[k] * angle);
  t += 1.0 / SR;
}
\end{lstlisting}

\subsubsection{Time-domain convolution}

Frequency-domain multiplication of spectra correspond to time-domain
convolution of signals, and such an operation allows for frequency filtering.
The time-domain implementation of convolution is a widely used technique in
many computer music algorithms and the general scheme can be seen in Figure
\ref{fig:FIR_Filter}.

\figura{FIR_Filter}{0.35}{TODO: change caption}

The high-level code for a time-domain convolution is:

\begin{lstlisting}
for (k = 0; k < N; k++)
  y[n] += b[k]*x[n-k];
\end{lstlisting}

\subsubsection{Fast Fourier Transform}

The Fast Fourier Transform (FFT) is a clever implementation of the traditional
Fourier Transform that brings its complexity down from $O(n^2)$ to
$O(n\log(n))$, where $n$ is the number of time-domain digital samples or,
equivalently, the number of frequency bins that describe the frequency
spectrum of the signal after the Transform computation. The FFT algorithm
takes advantage of redundancy and symmetry on intermediary steps of the
calculation and is used in many signal processing algorithms (see Figure
\ref{fig:butterfft}).

%-----------------------------------------------------------------------------
%\figura{./img/fft1.pdf}{0.35}{TODO: change caption}


\figura{butterfft}{0.35}{The FFT uses a divide-and-conquer approach and saves
intermediate results to accelerate the calculation of a signal spectrum. The
figure shows one step of an 8-point FFT calculation and how the results map to
frequency bins.}
%-----------------------------------------------------------------------------

\subsubsection{Benchmarking}

Each of the algorithms mentioned in the last sections have different
computational costs in terms of number of integer and floating-point
operations, and quantity of memory reads and writes (and amount of memory
accessed in each of these operations). 

In the context of real time audio processing in the Arduino, the algorithms mentioned above
bring natural questions regarding feasibility of processing:

\begin{itemize}
  \item Additive synthesis: what is the maximum number of oscillators that can
  be used to compute a new waveform in real time?
  \item Time-domain convolution: what is the maximum length of a filter that
  can be applied to an audio signal in real time?
  \item FFT: what is the maximum length of an FFT that can be computed in real time?
\end{itemize}

